# 📘 Chapter 2: 도커의 기본적인 사용법

## 2-1. 컨테이너로 HELLO WORLD 실행하기

프로그래밍을 배울 때 가장 먼저 해보는 것이 바로 "Hello World"죠? 도커도 마찬가지입니다. 복잡한 이론은 잠시 미뤄두고, 일단 Hello World 메시지를 출력하는 애플리케이션을 도커로 실행해보겠습니다.

```bash
docker container run diamol/ch02-hello-diamol
```

이 명령어는 무엇일까요? `docker container run` 명령은 컨테이너로 애플리케이션을 실행하라는 명령입니다.  
해당 애플리케이션은 미리 도커로 패키징되어 누구나 내려받을 수 있도록 공유된 것입니다.
위 예제의 컨테이너 패키지 이름은 `diamol/ch02-hello-diamol` 입니다. (패키지는 도커에서 **이미지**라고 불립니다!)

즉, `diamol/ch02-hello-diamol`이란 이미지를 컨테이너로 실행하라는 의미입니다.

### 최초 실행 시 결과

```bash
Unable to find image 'diamol/ch02-hello-diamol:latest' locally
latest: Pulling from diamol/ch02-hello-diamol
941f399634ec: Already exists
93931504196e: Pull complete
d7b1f3678981: Pull complete
Digest: sha256:c4f45e04025d10d14d7a96df2242753b925e5c175c3bea9112f93bf9c55d4474
Status: Downloaded newer image for diamol/ch02-hello-diamol:latest

---------------------
Hello from Chapter 2!
---------------------
My name is: ~
---------------------
Im running on: Linux 6.10.14-linuxkit aarch64
---------------------
My address is: inet ~~
```

이미지를 이용해 컨테이너를 실행하려면 먼저 이미지가 있어야 합니다.  
우리는 이미지를 가지고 있지 않기 때문에 `Unable to find image 'diamol/ch02-hello-diamol:latest' locally`라는 메시지가 나타납니다.  
그리고 이어서 도커가 이미지를 내려받는(pull) 메시지가 보입니다.

이미지를 내려받고 나면 내려받은 이미지를 사용해 컨테이너를 실행합니다.  
해당 이미지에는 애플리케이션을 실행하는 데 필요한 내용과 실행 방법이 정의되어 있기 때문에 Hello World라는 메시지가 나타납니다.

> 💡 **명령을 다시 실행하면?**  
> 도커는 이미지를 이미 pull했기 때문에 내려받는 부분이 사라지고 바로 컨테이너를 실행합니다!

### 도커의 핵심 워크플로우

이 일련의 과정이 도커의 핵심입니다:

1. **빌드**: 애플리케이션을 컨테이너에서 실행할 수 있도록 패키징하고
2. **공유**: 다른 사람이 패키지를 사용할 수 있도록 공유하고
3. **실행**: 패키지를 내려받아 컨테이너를 통해 애플리케이션을 실행한다

도커에서는 이 과정을 **빌드, 공유, 실행**이라고 부릅니다.

---

## 2-2. 컨테이너란 무엇일까?

도커 컨테이너는 말 그대로 물건을 담는 컨테이너와 비슷합니다.  
즉, **애플리케이션과 실행 환경(라이브러리, 설정, 종속성 등)을 하나로 묶어 격리된 공간에서 실행하는 단위**입니다.  
쉽게 말해, 컨테이너는 애플리케이션이 어디서든 동일하게 동작하도록 보장해주는 실행 박스입니다.

컨테이너는 각자 호스트명, IP 주소, 파일 시스템을 가진 것처럼 보이지만, 실제로는 도커가 호스트 OS 위에 가상 리소스를 만들어 제공합니다.

컴퓨터(호스트)는 이러한 컨테이너를 여러 개 실행시킬 수 있습니다.  
실행시킨 컨테이너들은 서로 독립적인 환경을 가지지만 컴퓨터(호스트)의 CPU와 메모리, OS 등을 공유합니다.

### VM vs 도커 컨테이너 비교

도커가 나오기 전에는 VM을 사용했습니다.  
VM도 컨테이너와 같이 애플리케이션이 어디서든 똑같이 동작하게 해주는 실행박스가 있습니다 (하지만 OS가 있는...).  
VM을 실행시키는 컴퓨터(호스트)의 OS를 공유하지 않고, 별도의 OS가 필요하다 보니 CPU와 메모리 자원을 많이 차지합니다.

| 구분              | 가상머신(VM)        | 도커 컨테이너  |
| ----------------- | ------------------- | -------------- |
| OS                | 각각 독립된 OS 필요 | 호스트 OS 공유 |
| 리소스 사용량     | 높음 (OS 오버헤드)  | 낮음           |
| 실행 속도         | 느림                | 빠름           |
| 실행 가능한 앱 수 | 적음                | 많음 (약 5배)  |

도커 컨테이너는 이를 해결해주었습니다.  
각각의 컨테이너는 호스트 컴퓨터의 OS를 공유하므로 필요한 리소스가 크게 줄어들며 실행도 빠르고 VM에 비해 더 많은 수(약 5배)의 애플리케이션을 실행할 수 있게 해줍니다.  
또한, VM과 마찬가지로 독립된 환경을 제공하므로 밀집과 격리가 동시에 달성되어 더 효율적입니다.

즉, **"많은 수의 애플리케이션을 효율적으로 실행"**하면서도 **"서로 충돌하지 않는 독립적인 실행 환경"**을 제공하는 것입니다.

> **밀집**: 같은 하드웨어 위에서 얼마나 많은 실행 단위를 동시에 돌릴 수 있는가를 의미합니다.  
> **격리**: 각 실행 단위가 서로 영향을 주지 않고 독립된 환경을 유지하는 것을 의미합니다.

---

## 2-3. 컨테이너를 원격 컴퓨터처럼 사용하기

컨테이너를 원격 컴퓨터처럼 사용할 수도 있습니다.

```bash
docker container run --interactive --tty diamol/base

Unable to find image 'diamol/base:latest' locally
latest: Pulling from diamol/base
941f399634ec: Already exists
716aca3e500c: Already exists
Digest: sha256:787fe221a14f46b55e224ea0436aca77d345c3ded400aaf6cd40125e247f35c7
Status: Downloaded newer image for diamol/base:latest
/ #
```

2-1의 예제와 마찬가지로 해당 이미지가 컴퓨터에 없기 때문에 pull로 내려받습니다.  
이미지를 내려받은 후에는 명령 프롬프트가 뜨는데, 이는 컨테이너 내부에 접속된 터미널 세션입니다.

- `--interactive`: 해당 플래그를 사용하면 컨테이너에 접속된 상태가 됩니다.
- `--tty`: 해당 플래그를 사용하면 터미널 세션을 통해 컨테이너를 조작하겠다는 의미입니다.

### 터미널에서 명령어 실행

```bash
/ # date
Wed Sep 24 12:52:23 UTC 2025
/ # ls
bin    etc    lib    mnt    proc   run    srv    tmp    var
dev    home   media  opt    root   sbin   sys    usr
```

위와 같이 일반 터미널과 같이 명령어 입력이 가능합니다.  
앞서 언급했듯이 도커 컨테이너는 호스트 컴퓨터의 OS를 공유하기 때문에 호스트 컴퓨터가 리눅스면 리눅스 셸이 뜨고, 윈도우면 윈도우 명령프롬프트가 뜨게 됩니다.

---

## 2-4. 컨테이너를 사용해 웹 사이트 호스팅하기

정적인 Hello World를 넘어서 실제 웹 애플리케이션을 컨테이너로 실행해보겠습니다.

```bash
docker container run --detach --publish 8080:80 diamol/ch02-hello-diamol-web
```

### 새로운 플래그들

- `--detach` (또는 `-d`): 컨테이너를 백그라운드에서 실행합니다.
- `--publish 8080:80` (또는 `-p`): 호스트의 8080 포트를 컨테이너의 80 포트에 연결합니다.

이제 브라우저에서 `http://localhost:8080`에 접속하면 컨테이너에서 실행 중인 웹 애플리케이션을 볼 수 있습니다!

### 포트 매핑의 이해

```
호스트 컴퓨터:8080 ──────► 컨테이너:80
```

외부에서는 호스트의 8080 포트로 접근하지만, 실제로는 컨테이너 내부의 80 포트에서 실행 중인 웹 서버에 연결됩니다.

### 도커 네트워킹의 원리

도커를 설치하면 호스트 컴퓨터의 **네트워크 계층에 도커가 끼어들게** 됩니다. 그러면 호스트 컴퓨터에서 들어오고 나가는 네트워크 트래픽을 모두 도커가 가로채서, 그중 필요한 것을 컨테이너에 전달할 수 있습니다.

#### 컨테이너의 네트워크 격리

**컨테이너는 기본적으로 외부 환경에 노출되지 않습니다.** 각 컨테이너는 고유의 IP 주소를 가지지만, 이 IP 주소는 도커가 관리하는 **내부 가상 네트워크 주소**이지 호스트 컴퓨터가 연결된 물리 네트워크에 연결된 것이 아닙니다.

```
물리 네트워크 (192.168.1.x)
    ↓
호스트 컴퓨터 (192.168.1.100)
    ↓
도커 내부 네트워크 (172.17.0.x)
    ↓
컨테이너들 (172.17.0.2, 172.17.0.3, ...)
```

#### 포트 공개(Port Publishing)의 실제 동작

그러므로 **컨테이너의 포트를 공개한다는 것**은 도커가 호스트 컴퓨터의 포트를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너로 전달해주는 것입니다.

예를 들어 `--publish 8080:80` 옵션의 경우:

1. 도커가 호스트의 8080 포트를 감시
2. 8080 포트로 들어오는 모든 트래픽을 캐치
3. 해당 트래픽을 컨테이너의 80 포트로 전달
4. 컨테이너의 응답을 다시 호스트의 8080 포트를 통해 외부로 전송

이 방식은 간단하지만 **도커의 효율성을 그대로** 누릴 수 있게 해줍니다. 컨테이너는 격리된 환경에서 안전하게 실행되면서도, 필요할 때만 외부와 통신할 수 있습니다.

---

## 2-5. 도커가 컨테이너를 실행하는 원리

도커를 설치하고 컨테이너를 실행하는 일은 매우 간단하지만, 뒤에서는 여러 컴포넌트들이 함께 작동합니다. 이 컴포넌트들이 어떻게 협력하는지 알아보겠습니다.

### 도커의 주요 컴포넌트들

#### 1. 도커 엔진 (Docker Engine)

**도커의 관리 기능을 담당하는 핵심 컴포넌트**입니다. 로컬 이미지 캐시를 관리하여 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 재사용합니다.

#### 2. 도커 API (Docker API)

**도커 엔진은 도커 API를 통해 맡은 기능을 수행**하며, 이는 표준 HTTP 기반 REST API입니다. 이 API를 통해 다양한 클라이언트가 도커 엔진과 통신할 수 있습니다.

#### 3. 도커 CLI (Docker CLI)

**도커 API의 클라이언트**로, 우리가 `docker container run` 같은 도커 명령을 사용할 때 실제로는 도커 API를 호출하는 역할을 합니다.

### 컴포넌트 간의 작동 원리

```
사용자 명령어 → 도커 CLI → 도커 API → 도커 엔진 → 컨테이너 실행
```

예를 들어, `docker container run diamol/ch02-hello-diamol` 명령을 실행하면:

1. **도커 CLI**가 명령어를 받아서 도커 API 호출로 변환
2. **도커 API**가 요청을 도커 엔진에 전달
3. **도커 엔진**이 로컬 이미지 캐시를 확인
4. 이미지가 없으면 도커 허브에서 다운로드
5. 이미지가 있으면 바로 컨테이너로 실행

> 도커 API가 표준 HTTP 기반이기 때문에, 도커 CLI뿐만 아니라 다양한 프로그래밍 언어로 도커를 제어할 수 있습니다. 이것이 도커가 다양한 개발 도구와 CI/CD 파이프라인에 쉽게 통합되는 이유입니다.

---
